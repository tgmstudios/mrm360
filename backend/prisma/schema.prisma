generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model BackgroundTask {
  id           String           @id @default(cuid())
  name         String
  description  String?
  status       TaskStatus       @default(PENDING)
  progress     Int              @default(0)
  result       Json?
  error        String?
  entityType   String?
  entityId     String?
  startedAt    DateTime?
  finishedAt   DateTime?
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt
  parentTaskId String?
  stepIndex    Int              @default(0)
  parentTask   BackgroundTask?  @relation("TaskToSubtasks", fields: [parentTaskId], references: [id], onDelete: Cascade)
  subtasks     BackgroundTask[] @relation("TaskToSubtasks")

  @@map("background_tasks")
}

model User {
  id             String          @id @default(cuid())
  email          String          @unique
  username       String?         @unique
  password       String?
  firstName      String
  lastName       String
  displayName    String?
  paidStatus     Boolean         @default(false)
  qrCode         String?         @unique
  role           Role            @default(MEMBER)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  authentikId    String?
  authentikPk    String?
  checkIns       CheckIn[]
  discordAccount DiscordAccount?
  rsvps          RSVP[]
  userClassRank  UserClassRank?
  userGroups     UserGroup[]
  userInterests  UserInterest[]
  userTeams      UserTeam[]
  payments       Payment[]
  eventTeamMembers EventTeamMember[]

  @@map("users")
}

model Group {
  id          String      @id @default(cuid())
  name        String      @unique
  description String?
  externalId  String?
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  teams       Team[]
  userGroups  UserGroup[]

  @@map("groups")
}

model UserGroup {
  id       String   @id @default(cuid())
  userId   String
  groupId  String
  joinedAt DateTime @default(now())
  group    Group    @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, groupId])
  @@map("user_groups")
}

model Team {
  id           String       @id @default(cuid())
  name         String
  description  String?
  type         TeamType
  subtype      TeamSubtype?
  parentTeamId String?
  groupId      String?
  createdAt    DateTime     @default(now())
  updatedAt    DateTime     @updatedAt
  events       Event[]
  group        Group?       @relation(fields: [groupId], references: [id])
  parentTeam   Team?        @relation("Subteams", fields: [parentTeamId], references: [id])
  subteams     Team[]       @relation("Subteams")
  userTeams    UserTeam[]

  @@map("teams")
}

model UserTeam {
  id       String   @id @default(cuid())
  userId   String
  teamId   String
  role     TeamRole @default(MEMBER)
  joinedAt DateTime @default(now())
  team     Team     @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
  @@map("user_teams")
}

model DiscordAccount {
  id            String   @id @default(cuid())
  userId        String   @unique
  discordId     String   @unique
  username      String
  discriminator String?
  avatar        String?
  linkedAt      DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("discord_accounts")
}

model DiscordConfig {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("discord_configs")
}

model UserInterest {
  id        String       @id @default(cuid())
  userId    String
  interest  InterestType
  createdAt DateTime     @default(now())
  user      User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, interest])
  @@map("user_interests")
}

model UserClassRank {
  id        String        @id @default(cuid())
  userId    String        @unique
  classRank ClassRankType
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt
  user      User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_class_ranks")
}

model Event {
  id                String         @id @default(cuid())
  title             String
  description       String?
  startTime         DateTime
  endTime           DateTime
  category          EventCategory
  linkedTeamId      String?
  wiretapWorkshopId String?
  attendanceType    AttendanceType @default(SOFT)
  checkInCode       String         @unique
  attendanceCap     Int?           // Maximum number of attendees (null = no cap)
  waitlistEnabled   Boolean        @default(false) // Whether to enable waitlist when cap is reached
  teamsEnabled      Boolean        @default(false) // Whether teams are enabled for this event
  membersPerTeam    Int?           @default(4) // Number of members per team for auto-assignment
  autoAssignEnabled Boolean        @default(false) // Whether to auto-assign confirmed RSVPs to teams
  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt
  checkIns          CheckIn[]
  linkedTeam        Team?          @relation(fields: [linkedTeamId], references: [id])
  rsvps             RSVP[]
  eventTeams        EventTeam[]

  @@map("events")
}

model RSVP {
  id        String     @id @default(cuid())
  userId    String
  eventId   String
  status    RSVPStatus @default(PENDING)
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  event     Event      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@map("rsvps")
}

model CheckIn {
  id          String   @id @default(cuid())
  userId      String
  eventId     String
  qrCode      String
  checkedInAt DateTime @default(now())
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, eventId])
  @@map("check_ins")
}

model EventTeam {
  id             String             @id @default(cuid())
  eventId        String
  teamNumber     Int                // Team number (1, 2, 3, etc.)
  wiretapTeamId  String?            // Optional Wiretap team ID for integration
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  event          Event              @relation(fields: [eventId], references: [id], onDelete: Cascade)
  members        EventTeamMember[]

  @@unique([eventId, teamNumber])
  @@map("event_teams")
}

model EventTeamMember {
  id          String    @id @default(cuid())
  eventTeamId String
  userId      String
  email       String    // Store email for wiretap sync
  joinedAt    DateTime  @default(now())
  eventTeam   EventTeam @relation(fields: [eventTeamId], references: [id], onDelete: Cascade)
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventTeamId, userId])
  @@map("event_team_members")
}

enum TaskStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
}

enum Role {
  ADMIN
  EXEC_BOARD
  MEMBER
  FIRST_YEAR
  SECOND_YEAR
  THIRD_YEAR
  FOURTH_YEAR
  ALUMNI_OTHER
}

enum TeamType {
  COMPETITION
  DEVELOPMENT
}

enum TeamSubtype {
  BLUE
  RED
  CTF
}

enum TeamRole {
  LEADER
  MEMBER
}

enum EventCategory {
  MEETING
  WORKSHOP
  COMPETITION
  SOCIAL
  TRAINING
}

enum AttendanceType {
  STRICT
  SOFT
}

enum RSVPStatus {
  PENDING
  CONFIRMED
  DECLINED
  MAYBE
  WAITLIST
}

enum InterestType {
  OFFENSE
  DEFENSE
  CTF
  GAMING
}

enum ClassRankType {
  FIRST_YEAR
  SECOND_YEAR
  THIRD_YEAR
  FOURTH_YEAR
  ALUMNI_OTHER
}

enum PaymentType {
  SEMESTER
  YEARLY
}

enum PaymentStatus {
  PENDING
  COMPLETED
  FAILED
  REFUNDED
}

model Payment {
  id              String        @id @default(cuid())
  userId          String
  amount          Decimal       @db.Decimal(10, 2)
  paymentType     PaymentType
  status          PaymentStatus @default(PENDING)
  paymentMethod   String?       // e.g., "stripe", "paypal", "cash", etc.
  transactionId   String?       // External payment processor transaction ID
  paidAt          DateTime?
  expiresAt       DateTime      // When this payment expires
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  user            User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("payments")
}
